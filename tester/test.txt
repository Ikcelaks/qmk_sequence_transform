--- str[0]: s ---
buffer: |s| (1)
output: |s| (1)
--- str[1]: c ---
buffer: |sc| (2)
output: |sc| (2)
searching from len 1, skips: 1
  checking match at index 461, tlen: 2, stack: s*, comp: c
  testing completion: [06(c), 06(c)]   match!
Missed rule: s* ⇒ sc
--- str[2]: h ---
buffer: |sch| (3)
output: |sch| (3)
searching from len 1, skips: 1
  checking match at index 461, tlen: 2, stack: s*, comp: c
searching from len 1, skips: 2
  checking match at index 1933, tlen: 3, stack: s*@, comp: h
  testing completion: [0B(h), 0B(h)]   match!
Missed rule: s*@ ⇒ s*h

// I'll ion I'll I'match

^i*  -> <I'm
^i*@ -> <ll

--
Handling rules where the trigger key is not a sequence token:
we have: `d@ -> develop`
rule we're looking at: `d@r -> developer` (how it's written in dict)
We actually want to find/show `d@r -> d@er`
let's call this new transform string `chained_transform`
pseudo code to get it:

1. seq_prefix = N-1 of seq;
2. trans_prefix = st_process(seq_prefix);
3. chained_transform = in transform, replace trans_prefix with seq_prefix;

Running this on `d@r -> developer`, we get:
1. seq_prefix = "d@"
2. trans_prefix = "develop"
3. chained_transform = "d@er"

we can now push chained_transform to the input buffer and run rule search,
and it should find the correct rule.
